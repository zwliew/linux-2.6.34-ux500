<!DOCTYPE book PUBLIC "-//OASIS//DTD DocBook XML V4.1.2//EN"
	"http://www.oasis-open.org/docbook/xml/4.1.2/docbookx.dtd" []>

<book id="STE-CG2900-fm-driver-template">
 <bookinfo>
  <title>V4L FM Radio Driver for C2900</title>

  <authorgroup>
   <author>
    <firstname>Hemant</firstname>
    <surname>Gupta</surname>
    <affiliation>
     <address>
      <email>hemant.gupta@stericsson.com</email>
     </address>
    </affiliation>
   </author>
  </authorgroup>

  <copyright>
   <year>2010</year>
   <holder>ST-Ericsson</holder>
  </copyright>

  <subjectset>
    <subject>
      <subjectterm>Connectivity</subjectterm>
    </subject>
  </subjectset>

  <legalnotice>
   <!-- Do NOT remove the legal notice below -->

  <para>
     This documentation is free software; you can redistribute
     it and/or modify it under the terms of the GNU General Public
     License as published by the Free Software Foundation; either
     version 2 of the License, or (at your option) any later
     version.
   </para>

   <para>
     This program is distributed in the hope that it will be
     useful, but WITHOUT ANY WARRANTY; without even the implied
     warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
     See the GNU General Public License for more details.
   </para>

   <para>
     You should have received a copy of the GNU General Public
     License along with this program; if not, write to the Free
     Software Foundation, Inc., 59 Temple Place, Suite 330, Boston,
     MA 02111-1307 USA
   </para>

   <para>
     For more details see the file COPYING in the source
     distribution of Linux.
   </para>
  </legalnotice>
 </bookinfo>

 <toc></toc>

 <chapter id="intro">
  <title>Introduction</title>
  <!-- Do NOT change the chapter id or title! -->
  <para>
    This documentation describes the functions provided by the CG2900 FM Driver.
  </para>
 </chapter>

 <chapter id="gettingstarted">
  <title>Getting Started</title>
  <!-- Do NOT change the chapter id or title! -->
  <para>
     There are no special compilation flags needed to build the CG2900
     FM Driver.
  </para>
  <para>
    There must be coeffecient and firmware files that match the used chip version inside the firmware folder.
    The files:
    <itemizedlist>
      <listitem><para>ste_fm_bt_src_coeff_info.fw.org</para></listitem>
      <listitem><para>ste_fm_ext_src_coeff_info.fw.org</para></listitem>
      <listitem><para>ste_fm_fm_coeff_info.fw.org</para></listitem>
      <listitem><para>ste_fm_fm_prog_info.fw.org</para></listitem>
    </itemizedlist>
    handle the mapping between chip version and correct firmware files (firmware and coeffecient files).
    The necessary firmware and coeffecient files should be placed with the extension <constant>.fw.org</constant>.
    Note that there is a limitation in the Kernel firmware system regarding name length of a file.
  </para>
  <section id="basic-tutorial">
    <title>Basic Tutorial</title>
    <para>
      To enable the CG2900 FM Driver using KConfig go to <constant>Device Drivers -> Multimedia devices </constant>
      and enable the following:
    <itemizedlist>
      <listitem><para>Video For Linux</para></listitem>
      <listitem><para>Enable Video For Linux API 1 compatible Layer</para></listitem>
      <listitem><para>Radio Adapters</para></listitem>
      <listitem><para>Radio Adapter -> ST-Ericsson CG2900 FM Radio support</para></listitem>
    </itemizedlist>
      Select the driver as built in kernel object.
    </para>

  <!-- TODO: If the driver needs preparations to be used
        (special compilation flags, files in the file system,
        knowledge about a specific domain etc), specify it here.
        Remove this chapter completely if there is nothing
        to mention and there is no tutorial needed.
        Do NOT change the chapter id or title! -->
  <!-- TODO: This guideline for this chapter may be extended
        during the user-guide guidelines drop. -->

  </section>
 </chapter>

 <chapter id="concepts">
  <title>Concepts</title>
  <!-- Do NOT change the chapter id or title! -->
  <para>
     The CG2900 FM driver acts as an interface between Video4Linux and STE-Protocol Driver. It configures the FM chip in FM Rx or FM Tx mode. It also sends the unformatted RDS data to the application fo decoding while in FM rx mode and sends the formatted RDS data to FM Chip while in Tx mode.
     <!-- TODO: A brief introduction about the concepts
           which are introduced by the driver.
           Remove this chapter completely if there are no
           special concepts introduced by this driver.
           Do NOT change the chapter id or title! -->
     <!-- TODO: This guideline for this chapter may be extended
           during the user-guide guidelines drop. -->
  </para>
   <para>
     <variablelist>
       <varlistentry>
         <term>FM Driver Working</term>
         <listitem>
         <para>
           In order to send and receive data on an H:4 channel, the FM Driver opens the channel by registering with the STE Protocol driver. After this the FM driver encapsulates the user operation into specific HCI comamnds and sends that data to the STE Connectivity Controller and waits till the response for the previous command is received. FM Driver in this way maintains the flow control.
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </para>
 </chapter>

 <chapter id="Tasks">
   <title>Tasks</title>
   <!-- Do NOT change the chapter id or title! -->

   <section id="Switching-On-FM">
     <title>Switch On FM</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Switching On FM</term>
         <listitem>
         <para>
           To switch on the FM the character device, /dev/radio0 should be opened from user space. This sets the FM Radio to Idle mode. To configure the FM Radio in Rx or Tx mode use the IOCTL's VIDIOC_S_TUNER and VIDIOC_S_MODULATOR respectively.
           <programlisting>

		int fd;
		fd = open("/dev/radio0", O_RDONLY);
		if(fd &lt; 0) {
			printf("open:error!!!\n");
			goto err;
		}

           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="Switching-Off-FM">
     <title>Switch Off FM</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Switching Off FM</term>
         <listitem>
         <para>
           To switch on the FM the character device /dev/radio0 should be opened from user space.
           <programlisting>

		if(fd &gt;= 0)
			close(fd);

           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="Rx-Mode">
     <title>Switching To FM Rx Mode</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Switching To FM Rx Mode</term>
         <listitem>
         <para>
           To switch on the FM Rx mode the IOCTL VIDIOC_S_TUNER should be called with appropriate parameters.
           <programlisting>

			memset(&amp;tuner, 0, sizeof(tuner));
			tuner.index = 0;
			tuner.rxsubchans |= V4L2_TUNER_SUB_STEREO;
			if (ioctl(fd, VIDIOC_S_TUNER, &amp;tuner) &lt; 0) {
				  printf("VIDIOC_S_TUNER:error!!\n");
				  return;

           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="Tx-Mode">
     <title>Switching To FM Tx Mode</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Switching To FM Tx Mode</term>
         <listitem>
         <para>
           To switch on the FM Tx mode the IOCTL VIDIOC_S_MODULATOR should be called with appropriate parameters.
           <programlisting>

			memset(&amp;modulator, 0, sizeof(modulator));
			modulator.index = 0;
			modulator.txsubchans |= V4L2_TUNER_SUB_STEREO;
			if (ioctl(fd, VIDIOC_S_MODULATOR, &amp;modulator) &lt; 0) {
				  printf("VIDIOC_S_MODULATOR:error!!\n");
				  return;

           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="FM-Standby">
     <title>Standby</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Making the FM Radio go into Standby Mode</term>
         <listitem>
         <para>
           To make the FM Radio go in Standby mode, the IOCTL VIDIOC_S_CTRL should be used. The id of the v4l2_control structure should be set to V4L2_CID_CG2900_RADIO_CHIP_STATE and the value of v4l2_control structure should be set as V4L2_CG2900_RADIO_STANDBY.
           <programlisting>

		struct v4l2_control sctrl;
		int ret;
		sctrl.id = V4L2_CID_CG2900_RADIO_CHIP_STATE;
                sctrl.value = V4L2_CG2900_RADIO_STANDBY;
                ret = ioctl(fd, VIDIOC_S_CTRL, &amp;sctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_S_CTRL:error!!\n");
		}
           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="Powerup-from-standby">
     <title>Powering Up FM From Standby Mode</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Powering Up FM Radio from Standby Mode</term>
         <listitem>
         <para>
           To power up the FM radio from standby mode, the IOCTL VIDIOC_S_CTRL should be used. The id of the v4l2_control structure should be set to V4L2_CID_CG2900_RADIO_CHIP_STATE and the value of v4l2_control structure should be set as V4L2_CG2900_RADIO_POWERUP.
           <programlisting>

		struct v4l2_control sctrl;
		int ret;
		sctrl.id = V4L2_CID_CG2900_RADIO_CHIP_STATE;
                sctrl.value = V4L2_CG2900_RADIO_POWERUP;
                ret = ioctl(fd, VIDIOC_S_CTRL, &amp;sctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_S_CTRL:error!!\n");
		}
           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="tune-frequency">
     <title>Tune Channel</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Tune to a particular station</term>
         <listitem>
         <para>
           To tune to a particular station, the IOCTL VIDIOC_S_FREQUENCY should be used. The frequency of the v4l2_frequency structure should be converted to V4L2 format.
           <programlisting>
		struct v4l2_frequency freq;
		int ret;

		/* Convert frequency in Hz to V4L2 Format */
		freq.frequency = (frequency * 2)/ 125;
                ret = ioctl(fd, VIDIOC_S_FREQUENCY, &amp;freq);
		if (ret &lt; 0) {
			printf("VIDIOC_S_FREQUENCY:error!!\n");
		}
           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="get-frequency">
     <title>Get Tuned Channel</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Get the Currently tuned Station Frequncy</term>
         <listitem>
         <para>
           To tune to a particular station, the IOCTL VIDIOC_G_FREQUENCY should be used. The frequency returned in the v4l2_frequency structure will be in V4L2 format.
           <programlisting>
		struct v4l2_frequency freq;
		int ret;

                ret = ioctl(fd, VIDIOC_G_FREQUENCY, &amp;freq);
		if (ret &lt; 0) {
			printf("VIDIOC_G_FREQUENCY:error!!\n");
			*frequency = 0;
			return;
		}
		/* Convert frequency to Hz from V4L2 Format */
		*frequency = (freq.frequency * 125)/2;
           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="get-signal-strength">
     <title>Retreive Signal Strength</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Retreive Signal Strength</term>
         <listitem>
         <para>
           To retreive the signal strength of the currently tuned channel in FM Rx mode, IOCTL VIDIOC_G_TUNER should be called. The current signal strength would be represented by the parameter signal of the v4l2_tuner structure.
           <programlisting>
		void get_signal_strength(int *rssi)
		{
			struct v4l2_tuner tuner;
			int ret;

			memset(&amp;tuner, 0, sizeof(tuner));
			tuner.index = 0;
			ret = ioctl(fd, VIDIOC_G_TUNER, &amp;tuner);
			if (ret &lt; 0) {
				printf("VIDIOC_G_TUNER:error!!\n");
				*rssi = 0;
				return;
			}
			*rssi = tuner.signal;
		}
           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="band-scan">
     <title>Scan Band</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Band Scan</term>
         <listitem>
         <para>
           To conduct a band scan, which searches for all available stations in the entire FM band, IOCTL VIDIOC_S_CTRL should be used with parameter id of the v4l2_control structure should be set to V4L2_CID_CG2900_RADIO_BANDSCAN and the value of v4l2_control structure should be set as V4L2_CG2900_RADIO_BANDSCAN_START. If the IOCTL returns successfully, a thread should be created to start polling to FM driver, to wait till scan is complete. When poll is complete, the found stations along with RSSI should be retrived using the IOCTL VIDIOC_G_EXT_CTRLS should be used with parameters as described in example code.
           <programlisting>
		void scan()
		{
			struct v4l2_control sctrl
			int ret;

			sctrl.id = V4L2_CID_CG2900_RADIO_BANDSCAN;
			sctrl.value = V4L2_CG2900_RADIO_BANDSCAN_START;

			ret = ioctl(fd, VIDIOC_S_CTRL, &amp;sctrl);
			if (ret &lt; 0) {
				printf("VIDIOC_S_CTRL:error!!\n");
			}
			pthread_create(&amp;fmScanThread, NULL, FmScanThread, NULL);
		}
		static void *FmScanThread(void *param)
		{
			struct v4l2_ext_controls scanResult;
			struct pollfd pollFd;
			long * p = NULL;
			int index, ret, count = 0;
			int err;

			pollFd.fd = fd;
			pollFd.events = POLLRDBAND;
			ret = poll(&amp;pollFd, 1, 1000);

			if(ret)
			{
				if(pollFd.revents &amp; POLLRDBAND)
				{
					/* Get the Number OF Channels */
					scanResult.count = 0;
					scanResult.ctrl_class = V4L2_CTRL_CLASS_USER;
					scanResult.controls = (struct v4l2_ext_control *) malloc(sizeof(struct v4l2_ext_control));
					scanResult.controls->id = V4L2_CID_CG2900_RADIO_BANDSCAN_GET_RESULTS;
					scanResult.controls->size = 0;
					scanResult.controls->string = NULL;
					err = ioctl(fd, VIDIOC_G_EXT_CTRLS, &amp; scanResult);

				if (err &lt; 0 &amp; &amp; errno !=  ENOSPC) {
					printf("VIDIOC_G_EXT_CTRLS:error!!\n");
					goto err;
				}
				/* Allocate memory to receive the data from driver */
				if(scanResult.controls->size &gt; 0 )
				{
					scanResult.controls->string = (long *)malloc(sizeof(long) * 2 * scanResult.controls->size );
					p = scanResult.controls->string;
					printf("\nNumber of Channels Found = %d \n", scanResult.controls->size);
					/* Retrieve the Data now */
					ret = ioctl(fd, VIDIOC_G_EXT_CTRLS, &amp;scanResult);
					if (ret &lt; 0) {
						printf("VIDIOC_G_EXT_CTRLS:error!!\n");
						goto err;
					}
					for (index = 0, count = 0; index &lt; scanResult.controls->size; index ++, count +=2) {
						printf("%d	 %d.%d		%d\n", index + 1, MEGAHRTZ((*(p +count + 0) * 125) / 2), *(p + count + 1));
					}
					err:
					free(p);
					free(scanResult.controls);
				}
				else if( pollFd.revents &amp; POLLHUP)
				{
					printf("\nScan Cancelled By User!!\n");
				}
				free(scanResult.controls);
			}

			else if( ret == 0){
				printf("\nError in Scanning, Timeout!!!\n");
			}
			return 0;
		}

           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="cancel-scan-seek">
     <title>Cancel Scan</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>Cancel Scan/Seek</term>
         <listitem>
         <para>
           To cancell an ongoing Band Scan or Seek, IOCTL VIDIOC_S_CTRL should be used with parameter id of the v4l2_control structure should be set to V4L2_CID_CG2900_RADIO_BANDSCAN and the value of v4l2_control structure should be set as V4L2_CG2900_RADIO_BANDSCAN_STOP.
           <programlisting>
		struct v4l2_control sctrl;
		int ret;

		sctrl.id = V4L2_CID_CG2900_RADIO_BANDSCAN;
		sctrl.value = V4L2_CG2900_RADIO_BANDSCAN_STOP;

		ret = ioctl(fd, VIDIOC_S_CTRL, &amp;sctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_S_CTRL:error!!\n");
		}
           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="rds-receive">
     <title>RDS Receive</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>RDS Receive</term>
         <listitem>
         <para>
           To enable or disable RDS for FM Rx, IOCTL VIDIOC_S_TUNER should be used with parameter rxsubchans of the v4l2_tuner structure set to V4L2_TUNER_SUB_RDS if rds needs to be enabled and the same value must not be set in case rds is to be disabled. A thread should be created and read() should be called to receive RDS data from driver. The RDS data received from FM Driver should be parsed in user space to retrive RDS information i.e Radio Text, Program Service Name, Program Identification, Program Type, Alternate Frequency, etc.
           <programlisting>
           void rds_rx_set(bool enable_rds)
           {
		struct v4l2_tuner tuner;
		int ret;

		memset(&amp;tuner, 0, sizeof(tuner));
		tuner.index = 0;
		if(enable_rds)
			tuner.rxsubchans |= V4L2_TUNER_SUB_RDS;
		else
			tuner.rxsubchans &amp; = ~V4L2_TUNER_SUB_RDS;
		ret = ioctl(fd, VIDIOC_S_TUNER, &amp;tuner);
		if (ret &lt; 0) {
			printf("VIDIOC_S_TUNER:error!!\n");
		}
	   }
           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="af-update_switch">
     <title>AF Update and Switching</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>AF Update &amp; Switching</term>
         <listitem>

	 <para>Alternate Frequency (AF) Handling needs to be done in user space.
	 </para>
	 <para>The application should use the AF RDS group data to compose a list of AFs when tuned to a new channel.
	 </para>
	 <para>When the reception of the currently tuned frequency falls below a set threshold, it can decide to switch to one of the alternative frequencies for this channel.
	 </para>
	 <para>The application can perform an AF Update, which returns the RSSI value for all or some of the channel's AFs. Thus allowing the hardware to switch to the AF with the highest RSSI.  The AF Update could be designed to stop as soon as it finds an AF with an acceptable RSSI level. In the event that all the AF RSSI values are lower than the base channel, the AF Switch would not be necessary.
	 </para>
	 <para>To know the RSSI of the alternative frequencies, the application can use the IOCTL VIDIOC_S_CTRL with parameter id set to V4L2_CID_CG2900_RADIO_RDS_AF_UPDATE_START, and the parameter value be set as the frequency in Hz for a channel from the AF List. If this call returns successfully,  the RSSI of the frequency can then be retrieved. Using IOCTL VIDIOC_G_CTRL, with the parameter id set to V4L2_CID_CG2900_RADIO_RDS_AF_UPDATE_GET_RESULT, and the output parameter value will contain the RSSI of the AF frequency.
	 </para>
	 <para>If it is still deemed necessary to switch channels, the next step is then to switch to an alternative frequency in the AF list. This can be done using the IOCTL VIDIOC_S_EXT_CTRLS, with:
	 </para>
	   <itemizedlist>

	   <listitem><para>Parameter id set to V4L2_CID_CG2900_RADIO_RDS_AF_SWITCH_START</para></listitem>
	   <listitem><para>Parameter size set to 2</para></listitem>
	   <listitem><para>Parameters filled as below (string field of the parameter) </para></listitem>
	         <listitem><para>Control class parameter set to V4L2_CTRL_CLASS_USER</para></listitem>
	         <listitem><para>The AF switch frequency in Hz</para></listitem>
	         <listitem><para>Expected PI code </para></listitem>
           </itemizedlist>
         <para>The application can check if the AF switch succeeded or not using the IOCTL VIDIOC_G_CTRL, with parameter id set to V4L2_CID_CG2900_RADIO_RDS_AF_SWITCH_GET_RESULT, and the output parameter value will contain the AF switch conclusion.
         </para>

	 <para> The example code below illustrates both the aforementioned functionalities.
	 </para>
	 <para>

           <programlisting>
           void PerformAFUpdate(long AF_Frequency, int *AF_Rssi)
           {
		struct v4l2_control sctrl, gctrl;
		int ret;

		sctrl.id = V4L2_CID_CG2900_RADIO_RDS_AF_UPDATE_START;
		sctrl.value = AF_Frequency;

		ret = ioctl(fd, VIDIOC_S_CTRL, &amp; sctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_S_CTRL:error!!\n");
		}
		gctrl.id = V4L2_CID_CG2900_RADIO_RDS_AF_UPDATE_GET_RESULT;
		ret = ioctl(fd, VIDIOC_G_CTRL, &amp; gctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_G_CTRL:error!!\n");
		}
		*AF_Rssi = gctrl.value;
	   }
           void PerformAFSwitch(long AF_BestFrequency, int AF_ExpectedPI, int *AF_SwitchConclusion)
           {
		struct v4l2_control gctrl;
		struct v4l2_ext_controls ext_ctrl;
		int ret;

		int conclusion;
		long freq;
		long *p = NULL;

		ext_ctrl.ctrl_class = V4L2_CTRL_CLASS_USER;
		ext_ctrl.controls = (struct v4l2_ext_control *) malloc(sizeof(struct v4l2_ext_control));

		ext_ctrl.count = 0;
		ext_ctrl.controls->id = V4L2_CID_CG2900_RADIO_RDS_AF_SWITCH_START;
		ext_ctrl.controls->size = 2;
		ext_ctrl.controls->string = (long *)malloc(sizeof(long) * ext_ctrl.controls->size);
		p = ext_ctrl.controls->string;
		memcpy(p, &amp; AF_BestFrequency, sizeof(long));
		memcpy(p + sizeof(long), &amp; AF_ExpectedPI, sizeof(int));


		ret = ioctl(fd, VIDIOC_S_EXT_CTRLS, &amp; ext_ctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_S_EXT_CTRLS:error!!\n");
		}
		free(ext_ctrl.controls->string);
		free(ext_ctrl.controls);

		gctrl.id = V4L2_CID_CG2900_RADIO_RDS_AF_SWITCH_GET_RESULT;
		ret = ioctl(fd, VIDIOC_G_CTRL, &amp; gctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_G_CTRL:error!!\n");
		}
		*AF_SwitchConclusion = gctrl.value;
	   }
           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>

   <section id="rds-transmit">
     <title>RDS Transmit</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>RDS Transmit</term>
         <listitem>
         <para>
           To enable or disable RDS during FM Tx, IOCTL VIDIOC_S_MODULATOR should be used with parameter txsubchans of the v4l2_modulator structure set to V4L2_TUNER_SUB_RDS if rds needs to be enabled and the same value must not be set in case rds is to be disabled. For Trasmitting RDS Data like PI, PTY, PSN, RT, VIDIOC_S_EXT_CTRLS IOCTL should be used with the id set to V4L2_CID_RDS_TX_PI, V4L2_CID_RDS_TX_PTY, V4L2_CID_RDS_TX_PS_NAME and V4L2_CID_RDS_TX_RADIO_TEXT respectively. Below example shows how to transmit various RDS functionalities.
           <programlisting>
           void rds_tx_set(bool enable_rds)
           {
		struct v4l2_modulator modulator;
		int ret;

		memset(&amp;modulator, 0, sizeof(modulator));
		modulator.index = 0;
		if(enable_rds)
			modulator.txsubchans |= V4L2_TUNER_SUB_RDS;
		else
			modulator.txsubchans &amp; = ~V4L2_TUNER_SUB_RDS;
		ret = ioctl(fd, VIDIOC_S_MODULATOR, &amp; modulator);
		if (ret &lt; 0) {
			printf("VIDIOC_S_MODULATOR:error!!\n");
		}
	   }
           void rds_tx_PI(void *value)
           {
		struct v4l2_ext_controls ext_ctrl;
		int ret;
		unsigned short *pi_code = (unsigned short *)value;

		ext_ctrl.ctrl_class = V4L2_CTRL_CLASS_FM_TX;
		ext_ctrl.controls = (struct v4l2_ext_control *) malloc(sizeof(struct v4l2_ext_control));


		ext_ctrl.count = 0;
		ext_ctrl.controls->id = V4L2_CID_RDS_TX_PI;
		ext_ctrl.controls->size = 0;
		ext_ctrl.controls->string = NULL;
		ext_ctrl.controls->value = *pi_code;

		ret = ioctl(fd, VIDIOC_S_EXT_CTRLS, &amp; ext_ctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_S_EXT_CTRLS:error!!\n");
		}
		free(ext_ctrl.controls);
	   }
           void rds_tx_PTY(void *value)
           {
		struct v4l2_ext_controls ext_ctrl;
		int ret;
		unsigned short *pty_code = (unsigned short *)value;

		ext_ctrl.ctrl_class = V4L2_CTRL_CLASS_FM_TX;
		ext_ctrl.controls = (struct v4l2_ext_control *) malloc(sizeof(struct v4l2_ext_control));


		ext_ctrl.count = 0;
		ext_ctrl.controls->id = V4L2_CID_RDS_TX_PTY;
		ext_ctrl.controls->size = 0;
		ext_ctrl.controls->string = NULL;
		ext_ctrl.controls->value = *pty_code;

		ret = ioctl(fd, VIDIOC_S_EXT_CTRLS, &amp; ext_ctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_S_EXT_CTRLS:error!!\n");
		}
		free(ext_ctrl.controls);
	   }
           void rds_tx_PSN(void *value)
           {
		struct v4l2_ext_controls ext_ctrl;
		int ret;
		char *psn = (char *)value;

		ext_ctrl.ctrl_class = V4L2_CTRL_CLASS_FM_TX;
		ext_ctrl.controls = (struct v4l2_ext_control *) malloc(sizeof(struct v4l2_ext_control));


		ext_ctrl.count = 0;
		ext_ctrl.controls->id = V4L2_CID_RDS_TX_PS_NAME;
		ext_ctrl.controls->size = strlen(psn);
		ext_ctrl.controls->value = 0;
		ext_ctrl.controls->string = (char *)malloc(ext_ctrl.controls->size);
		memcpy(ext_ctrl.controls->string, psn, ext_ctrl.controls->size);

		ret = ioctl(fd, VIDIOC_S_EXT_CTRLS, &amp; ext_ctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_S_EXT_CTRLS:error!!\n");
		}
		free(ext_ctrl.controls->string);
		free(ext_ctrl.controls);

	   }
           void rds_tx_RT(void *value)
           {
		struct v4l2_ext_controls ext_ctrl;
		int ret;
		char *radio_text = (char *)value;

		ext_ctrl.ctrl_class = V4L2_CTRL_CLASS_FM_TX;
		ext_ctrl.controls = (struct v4l2_ext_control *) malloc(sizeof(struct v4l2_ext_control));


		ext_ctrl.count = 0;
		ext_ctrl.controls->id = V4L2_CID_RDS_TX_RADIO_TEXT;
		ext_ctrl.controls->size = strlen(radio_text);
		ext_ctrl.controls->value = 0;
		ext_ctrl.controls->string = (char *)malloc(ext_ctrl.controls->size);
		memcpy(ext_ctrl.controls->string, radio_text, ext_ctrl.controls->size);

		ret = ioctl(fd, VIDIOC_S_EXT_CTRLS, &amp; ext_ctrl);
		if (ret &lt; 0) {
			printf("VIDIOC_S_EXT_CTRLS:error!!\n");
		}
		free(ext_ctrl.controls->string);
		free(ext_ctrl.controls);

	   }

           </programlisting>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
   </section>
 </chapter>

 <chapter id="driver-configuration">
   <title>Driver Configuration and Interaction</title>
   <!-- Do NOT change the chapter id or title! -->
   <para>
     For debug purposes the variable ste_fm_debug_level in the file platformosapi.c can be changed to set how much debug printouts
     that shall be generated.
     <itemizedlist>
       <listitem><para>1 = Error prints</para></listitem>
       <listitem><para>2 = General info, e.g. function entries</para></listitem>
       <listitem><para>3 = All Debug prints</para></listitem>
       <listitem><para>4 = Data content, i.e. contents of the transferred data</para></listitem>
     </itemizedlist>
     <!-- TODO: Use this paragraph as an introduction to driver
           configuration and interaction. Describe the big picture. -->
     <!-- TODO: This chapter contains driver specific way to perform
           configuration and interaction. The chapter includes a
           number of sections. They should not be removed and if
           the driver does not have the specific support for
           configuration or interaction should the text "not
           applicable" be inserted. Do NOT change the chapter id
           or title! -->
     <!-- TODO: This guideline for this chapter may be extended
           during the user-guide guidelines drop. -->
   </para>

   <section id="driver-implemented-operations">
     <title>Implemented operations in driver</title>
     <para>
       <!-- TODO: Describe the actual usage of the driver. Specify the actual
            implemented operations in struct <structname>file_operations</structname>
            and any other set of operations. Create a table with two columns
            (see example in intro chapter how to create a table).
            Column one list all operations supported (read,
            write, open, close, ioctl etc) and column two a description of the
            semantics of the operations in the specific context of the device
            driver from the users perspective. Document the operations in a way
            that a user of the driver can be helped. -->
     </para>
     <para>
       <table>
         <title> Supported device driver operations when using character device </title>
         <tgroup cols="2"><tbody>
           <row><entry> open </entry> <entry> Opening a character device will Initialize the FM Chip and download the firmware files.</entry> </row>
           <row><entry> close </entry> <entry> Closes a character device willdeinitialize the FM Chip.</entry> </row>
           <row><entry> poll </entry> <entry> Polling a character device will check if there is requested data is available or not.</entry> </row>
           <row><entry> read </entry> <entry> Reading from a character device reads RDS data from the Chip</entry> </row>
         </tbody></tgroup>
       </table>
     </para>
   </section>

   <section id="driver-loading">
     <title>Driver loading parameters</title>
     <para>
       <!-- TODO: Describe parameters that can be specified at kernel
            driver loading with insmod or modprobe. If the driver
            has no parameters to be specified at load time, replace this
            text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term>radio_nr</term>
         <listitem>
         <para>
           <variablelist>
             <varlistentry>
               <term>Parameter type</term>
               <listitem><synopsis><type>int</type></synopsis></listitem>
             </varlistentry>
             <varlistentry>
               <term>Default value</term>
               <listitem><para>0</para></listitem>
             </varlistentry>
             <varlistentry>
               <term>Runtime readable/modifiable</term>
               <listitem><para>Readable</para></listitem>
             </varlistentry>
             <varlistentry>
               <term>Description</term>
               <listitem>
               <para>
                 The parameter radio_nr in radio-CG2900.c can be set to register a particular minor number with Video4Linux. Currently this parameter is set to 0 by default, signifying that the "\dev\radio0" is the character device assigned to CG2900 FM Driver in Video4Linux.
		 If the Platform has more than 1 radio drivers, the radio_nr parameter should be changed in file radio-CG2900.c.
               </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term>Checking the Radio Number</term>
               <listitem>
               <para>
	       cat sys/module/radio_CG2900/parameters/radio_nr.
               </para>
               <para>
		The above command gets the radio number registered with
		Video4Linux. This is used for opening the FM Radio
		character device from user space.
               </para>
               </listitem>
             </varlistentry>
           </variablelist>
         </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term>grid</term>
         <listitem>
         <para>
           <variablelist>
             <varlistentry>
               <term>Parameter type</term>
               <listitem><synopsis><type>int</type></synopsis></listitem>
             </varlistentry>
             <varlistentry>
               <term>Default value</term>
               <listitem><para>1</para></listitem>
             </varlistentry>
             <varlistentry>
               <term>Runtime readable/modifiable</term>
               <listitem><para>Readable</para></listitem>
             </varlistentry>
             <varlistentry>
               <term>Description</term>
               <listitem>
               <para>
                 The parameter grid in radio-CG2900.c defines the spacing to be used in Khz while switching on FM Radio.
                 <itemizedlist>
                   <listitem><para>0:  50 kHz (China)</para></listitem>
                   <listitem><para>1: 100 kHz (Europe, Japan)</para></listitem>
                   <listitem><para>2: 200 kHz (USA)</para></listitem>
                </itemizedlist>
               </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term>Changing the Grid</term>
               <listitem>
               <para>
		echo 1 &gt; /sys/module/radio_CG2900/parameters/grid.
               </para>
               <para>
		The above command sets the radio band spacing between
		two adjacent radio channels, in this case sets to 100KHz
		suitable for Europe. The change is applicable before
		switching on FM Radio, otherwise the change takes effect
		from next FM switch on.
               </para>
               <para>
		Note: The Grid parameter cannot be changed during FM radio is operational.
               </para>
               <para>
		The user must change the grid value and restart the FM radio when moving into a different radio region.
               </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term>Checking the current Grid Value</term>
               <listitem>
               <para>
		cat sys/module/radio_CG2900/parameters/grid.
               </para>
               <para>
		The above command gets the radio band spacing
		between two adjacent radio channels currently set.
               </para>
               </listitem>
             </varlistentry>
            </variablelist>
         </para>
         </listitem>
       </varlistentry>


       <varlistentry>
         <term>band</term>
         <listitem>
         <para>
           <variablelist>
             <varlistentry>
               <term>Parameter type</term>
               <listitem><synopsis><type>int</type></synopsis></listitem>
             </varlistentry>
             <varlistentry>
               <term>Default value</term>
               <listitem><para>0</para></listitem>
             </varlistentry>
             <varlistentry>
               <term>Runtime readable/modifiable</term>
               <listitem><para>Readable</para></listitem>
             </varlistentry>
             <varlistentry>
               <term>Description</term>
               <listitem>
               <para>
                 The parameter band in radio-CG2900.c defines the band to be used while switching on FM Radio.
                 <itemizedlist>
                   <listitem><para>0: 87.5 - 108 MHz (USA, Europe)</para></listitem>
                   <listitem><para>1: 76   -  90 MHz (Japan)</para></listitem>
                   <listitem><para>2: 70   - 108 MHz (China wide band)</para></listitem>
                </itemizedlist>
               </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term>Changing the Band</term>
               <listitem>
               <para>
		echo 0 &gt; /sys/module/radio_CG2900/parameters/band.
               </para>
               <para>
		The above command sets the FM band to be used.
		In this case, it sets the FM band 87.5 - 100 MHz.
		The change is applicable before switching on FM Radio,
		otherwise the change takes effect from next FM switch on.
               </para>
               <para>
		Note: The band parameter cannot be changed during FM radio is operational.
               </para>
               <para>
		The user must change the band value and restart the FM radio when moving into a different radio region.
               </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term>Checking the current Band Value</term>
               <listitem>
               <para>
		cat sys/module/radio_CG2900/parameters/band.
               </para>
               <para>
		The above command gets the current radio band set.
               </para>
               </listitem>
             </varlistentry>
           </variablelist>
         </para>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term>ste_fm_debug_level</term>
         <listitem>
         <para>
           <variablelist>
             <varlistentry>
               <term>Parameter type</term>
               <listitem><synopsis><type>int</type></synopsis></listitem>
             </varlistentry>
             <varlistentry>
               <term>Default value</term>
               <listitem><para>1</para></listitem>
             </varlistentry>
             <varlistentry>
               <term>Runtime readable/modifiable</term>
               <listitem><para>Readable</para></listitem>
             </varlistentry>
             <varlistentry>
               <term>Description</term>
               <listitem>
               <para>
                 The parameter ste_fm_debug_level in platformosapi.c defines the debug level that is currently used.
                 The higher the debug level the more print-outs are received in the terminal window.
                 The following values are supported:
                 <itemizedlist>
                   <listitem><para>1 = Error prints</para></listitem>
                   <listitem><para>2 = General info, e.g. function entries</para></listitem>
                   <listitem><para>3 = All Debug prints</para></listitem>
                   <listitem><para>4 = Data content, i.e. contents of the transferred data</para></listitem>
                 </itemizedlist>
               </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term>Changing the Log Level</term>
               <listitem>
               <para>
		echo 3 &gt; /sys/module/radio_CG2900/parameters/ste_fm_debug_level.
               </para>
               <para>
		The above command sets the Logging level of FM Driver.
		In this case, it set will print all the debug messages
		except the HCI commans exchanged with FM Chip.
               </para>
               </listitem>
             </varlistentry>
             <varlistentry>
               <term>Checking the current Log Level</term>
               <listitem>
               <para>
		cat sys/module/radio_CG2900/parameters/ste_fm_debug_level.
               </para>
               <para>
		The above command gets the current debug log level set.
               </para>
               </listitem>
             </varlistentry>
           </variablelist>
         </para>
         </listitem>
       </varlistentry>
     </variablelist>
     <para>
       <!-- TODO: This guideline for this section may be extended
            during the user-guide guidelines drop. -->
     </para>
   </section>

   <section id="driver-ioctl">
     <title>Driver IO Control</title>
     <para>
       <!-- TODO: Describe driver parameters that can be modified
            in runtime. Make a list of all device-dependent request code with
            description of arguments, meaning etc.  If the driver has no IO control
            interface, replace this text with "Not Applicable". -->
     </para>
     <variablelist>
       <varlistentry>
         <term><constant>VIDIOC_QUERYCAP</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Get</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_capability</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_QUERYCAP</constant> IOCTL is used to query the capabilities supported by FM Driver. IF the FM Driver supports FM Rx it should set the capabilities field bit should be bitwise OR'd with V4L2_CAP_TUNER, otherwise if it supports FM Tx, the capabilities field bit should  be bitwise OR'd with V4L2_CAP_MODULATOR.
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to retrive the Capabilities successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

	<varlistentry>
         <term><constant>VIDIOC_G_TUNER</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Get</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_tuner</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_G_TUNER</constant> IOCTL gets the FM Radio Tuner properties supported by FM Radio. It is also used to retrieve RDS status, mono/stereo status and Signal strength of the tuned channel. These values are valid when FM is configured using IOCTL VIDIOC_S_TUNER, i.e in FM Rx mode.
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to retrive the tuner properties successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><constant>VIDIOC_S_TUNER</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Set</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_tuner</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_S_TUNER</constant> IOCTL configures the FM radio in Rx mode. Only 1 FM Tuner is supported by FM Driver.
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to set the tuner properties successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

	<varlistentry>
         <term><constant>VIDIOC_G_MODULATOR</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Get</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_tuner</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
                The <constant>VIDIOC_G_MODULATOR</constant> IOCTL gets the FM Radio Modulator properties supported by FM Radio. It is also used to retrieve RDS status and mono/stereo status. These values are valid when FM is configured using IOCTL VIDIOC_S_MODULATOR, i.e in FM Tx mode.
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to retrive the tuner properties successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><constant>VIDIOC_S_MODULATOR</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Set</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_modulator</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_S_MODULATOR</constant> IOCTL configures the FM radio in Tx mode. Only 1 FM Modulator is supported by FM Driver.
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to set the modulator properties successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><constant>VIDIOC_S_FREQUENCY</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Set</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_frequency</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_S_FREQUENCY</constant> IOCTL sets the frequency on FM radio in Rx or Tx mode. The frequency parameter passed is in V4L2 format.
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to set the frequency successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><constant>VIDIOC_G_FREQUENCY</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Set</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_modulator</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_G_FREQUENCY</constant> IOCTL retrives the currently set frequency on FM Radio in Rx or Tx mode.
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to get the frequency successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><constant>VIDIOC_S_HW_FREQ_SEEK</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Set</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_hw_freq_seek</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_S_HW_FREQ_SEEK</constant> IOCTL starts the seek operation when FM Radio is configured in Rx mode. The direction parameter indicates the direction of seeking from the current station. At present the FM Driver ignores the wrap_Around parameter and unconditional wrap around is supported. If the operation is started successfully, the application should use poll() to identify when the seek is over.
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to start the seek successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><constant>VIDIOC_G_CTRL</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Get</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_control</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_G_CTRL</constant> IOCTL to retrive value of a paticular control. The following controls are supported by FM Driver:
               <itemizedlist>
               <listitem><para>
               V4L2_CID_AUDIO_VOLUME
               </para></listitem>
               <listitem><para>
               V4L2_CID_AUDIO_MUTE
               </para></listitem>
               <listitem><para>
               V4L2_CID_AUDIO_BALANCE
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_RSSI_THRESHOLD
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_SELECT_ANTENNA
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_RDS_AF_UPDATE_GET_RESULT
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_RDS_AF_SWITCH_GET_RESULT
               </para></listitem>
               </itemizedlist>
               Common Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to retrive the value of the control successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
              </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><constant>VIDIOC_S_CTRL</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Set</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_control</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
              <para>
               The <constant>VIDIOC_S_CTRL</constant> IOCTL to set value of a paticular control. The following controls are supported by FM Driver:
               <itemizedlist>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_CHIP_STATE
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_BANDSCAN
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_BLOCKSCAN_START
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_SELECT_ANTENNA
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_RSSI_THRESHOLD
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_RDS_AF_UPDATE_START
               </para></listitem>
               </itemizedlist>
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to set the value of the control successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><constant>VIDIOC_G_EXT_CTRLS</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Get</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_ext_controls</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_G_EXT_CTRLS</constant> IOCTL to retrive value of a paticular control. This is used when a control class is defined or when the value to be retrived is more than 1 parameter(s). Only V4L2_CTRL_CLASS_FM_TX class is supported for this IOCTL in FM Driver. The following controls are supported by FM Driver:
               <itemizedlist>
               <listitem><para>
               V4L2_CID_RDS_TX_DEVIATION
               </para></listitem>
               <listitem><para>
               V4L2_CID_PILOT_TONE_ENABLED
               </para></listitem>
               <listitem><para>
               V4L2_CID_PILOT_TONE_DEVIATION
               </para></listitem>
               <listitem><para>
               V4L2_CID_TUNE_PREEMPHASIS
               </para></listitem>
               <listitem><para>
               V4L2_CID_TUNE_POWER_LEVEL
               </para></listitem>
               </itemizedlist>
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to retrive the value(s) of the control successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

       <varlistentry>
         <term><constant>VIDIOC_S_EXT_CTRLS</constant></term>
         <listitem>
         <variablelist>
           <varlistentry>
             <term>Direction</term>
             <listitem><para>Set</para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Parameter</term>
             <listitem><synopsis><type>v4l2_ext_controls</type></synopsis></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>
               The <constant>VIDIOC_S_CTRL</constant> IOCTL to set value of a paticular control when the parameters to be set are more than 1 parameter or when a control class is defined. At present only the V4L2_CTRL_CLASS_FM_TX and V4L2_CTRL_CLASS_USER control classes are supported by FM Driver. The following controls are supported by FM Driver:
               <itemizedlist>
               <listitem><para>
               V4L2_CID_RDS_TX_DEVIATION
               </para></listitem>
               <listitem><para>
               V4L2_CID_RDS_TX_PI
               </para></listitem>
               <listitem><para>
               V4L2_CID_RDS_TX_PTY
               </para></listitem>
               <listitem><para>
               V4L2_CID_RDS_TX_PS_NAME
               </para></listitem>
               <listitem><para>
               V4L2_CID_RDS_TX_RADIO_TEXT
               </para></listitem>
               <listitem><para>
               V4L2_CID_PILOT_TONE_ENABLED
               </para></listitem>
               <listitem><para>
               V4L2_CID_PILOT_TONE_DEVIATION
               </para></listitem>
               <listitem><para>
               V4L2_CID_TUNE_PREEMPHASIS
               </para></listitem>
               <listitem><para>
               V4L2_CID_TUNE_POWER_LEVEL
               </para></listitem>
               <listitem><para>
               V4L2_CID_CG2900_RADIO_RDS_AF_SWITCH_START
               </para></listitem>
               </itemizedlist>
               Returned values are:
               <itemizedlist>
                 <listitem><para>If IOCTL is able to set the value of the control successfully without errors the IOCTL function will return 0.</para></listitem>
                 <listitem><para>A negative value will indicate error.</para></listitem>
               </itemizedlist>
             </para>
             </listitem>
           </varlistentry>
         </variablelist>
         </listitem>
       </varlistentry>

     </variablelist>
   </section>

   <section id="driver-sysfs">
     <title>Driver Interaction with Sysfs</title>
     <para>
       <!-- TODO: Describe data available for read and write on the drivers
            Sysfs entry.  Specify where the entry for the device is located in
            Sysfs such as <filename>/sys/devices/*</filename>, <filename>/sys/devices/*</filename>
            , etc.
            Specify the data types for the attributes. Specify if the
            attributes are read-only or write-only. If the driver has no Sysfs
            interface, replace this text with "Not Applicable". -->
       Not Applicable
     </para>
   </section>

   <section id="driver-proc">
     <title>Driver Interaction using /proc filesystem</title>
     <para>
       Not Applicable
       <!-- TODO: Describe data available for read and write on the drivers
            /proc entry. Specify where the entry for the device is located.
            Specify the data types for the attributes. Specify if the
            attributes are read-only or writeonly. If the driver has no /proc
            interface, replace this text with "Not Applicable". -->
     </para>
   </section>

   <section id="driver-other">
     <title>Other means for Driver Interaction</title>
     <para>
       <!-- TODO: Does the driver have any configurations files? Describe other means
            for driver status access or configuration. If the driver has no other
            means (besides the one in already described in this chapter), replace
            this text with "Not Applicable". -->
       Not Applicable
     </para>
   </section>

 <section id="driver-node">
   <title>Driver Node File</title>
     <variablelist>
     <varlistentry>
       <term>FM Radio Device</term>
       <listitem>
         <variablelist>
           <varlistentry>
             <term>File</term>
             <listitem><para><filename>/dev/radio0</filename></para></listitem>
           </varlistentry>
           <varlistentry>
             <term>Description</term>
             <listitem>
             <para>The radio device for FM Radio.</para>
             </listitem>
           </varlistentry>
         </variablelist>
       </listitem>
     </varlistentry>
    </variablelist>
  </section>

 </chapter>

 <chapter id="bugs">
   <title>Known Bugs And Limitations</title>
   <!--  Do NOT change the chapter id or title! -->
   <para>
     <variablelist>
     <varlistentry>
       <term>Problems in Band Scan &amp; Seek with Wired Headset</term>
       <listitem>
         <para>
           During Band Scan many stations are found, when the Headset Wire is plugged into headset jack of Platform, which are not actual FM Stations but noise. The same issue comes while trying to do search up/down. This issue is under investiigation.
           <!-- TODO: Briefly describe the limitation, unless all
              information is already present in the title.
              Use full english sentences.
              Repeat the varlistentry for each limitation.
              If none are known, replace this varlistentry
              with the one below. -->
           <!-- TODO: This guideline for this chapter may be extended
              during the user-guide guidelines drop. -->
         </para>
       </listitem>
     </varlistentry>
     </variablelist>

     <variablelist>
     <varlistentry>
       <term>Problems in Block Scan to retreive RSSI of channels in FM Band</term>
       <listitem>
         <para>
           The Block Scan retrives many stations which are not actual FM stations, this is currently under investigation.
           <!-- TODO: Briefly describe the limitation, unless all
              information is already present in the title.
              Use full english sentences.
              Repeat the varlistentry for each limitation.
              If none are known, replace this varlistentry
              with the one below. -->
           <!-- TODO: This guideline for this chapter may be extended
              during the user-guide guidelines drop. -->
         </para>
       </listitem>
     </varlistentry>
     </variablelist>

   </para>
 </chapter>

 <chapter id="internal-functions">
   <title>Internal Functions Provided</title>
   <para>
	List of internal functions used in FM Driver.
   </para>
   <!-- Do NOT change the chapter id or title! -->
   <!-- TODO: Replace with link to appropriate headerfile(s),
        source file(s), or both. One per row, ensure the
        exclamation mark is on the first column! If no
        appropriate header or source file exist describing a public interface,
        replace the inclusion with a paragraph containing the text
        "Not Applicable"-->
  <section id="radio-CG2900.c">
    <title>radio-CG2900.c</title>
!Idrivers/media/radio/CG2900/radio-CG2900.c
  </section>
  <section id="stefmapi.h">
    <title>stefmapi.h</title>
!Idrivers/media/radio/CG2900/stefmapi.h
  </section>
  <section id="stefmapi.c">
    <title>stefmapi.c</title>
!Idrivers/media/radio/CG2900/stefmapi.c
  </section>
  <section id="fmdriver.h">
    <title>fmdriver.h</title>
!Idrivers/media/radio/CG2900/fmdriver.h
  </section>
  <section id="fmdriver.c">
    <title>fmdriver.c</title>
!Idrivers/media/radio/CG2900/fmdriver.c
  </section>
  <section id="platformosapi.h">
    <title>platformosapi.h</title>
!Idrivers/media/radio/CG2900/platformosapi.h
  </section>
  <section id="platformosapi.c">
    <title>platformosapi.c</title>
!Idrivers/media/radio/CG2900/platformosapi.c
  </section>
 </chapter>

</book>
